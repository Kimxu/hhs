package kimxu.hhs.z_volley.tools;import android.os.Environment;import java.io.BufferedReader;import java.io.ByteArrayOutputStream;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;import java.io.InputStream;import java.util.regex.Pattern;import java.util.zip.CRC32;import java.util.zip.CheckedInputStream;import kimxu.hhs.z_base.data.FileInfo;import kimxu.hhs.z_volley.structure.ByteArrayPool;import kimxu.hhs.z_volley.structure.PoolingByteArrayOutputStream;public class FileHelper {	public static final int FOLDER_TYPE_LOG = 0;	public static final int FOLDER_TYPE_DB = 1;	public static final String LOG_FOLDER_NAME = "app_china_log";	public static final String DB_FOLDER_NAME = "dbs";	// public static final int S_IRWXU = 00700;	// public static final int S_IRUSR = 00400;	// public static final int S_IWUSR = 00200;	// public static final int S_IXUSR = 00100;	//	// public static final int S_IRWXG = 00070;	// public static final int S_IRGRP = 00040;	// public static final int S_IWGRP = 00020;	// public static final int S_IXGRP = 00010;	//	// public static final int S_IRWXO = 00007;	// public static final int S_IROTH = 00004;	// public static final int S_IWOTH = 00002;	// public static final int S_IXOTH = 00001;	public static int FILE_READ_BUFFER = 10240;	public static byte[] readFromStream(InputStream in, ByteArrayPool mPool,			int len) throws IOException {		PoolingByteArrayOutputStream bytes = new PoolingByteArrayOutputStream(				mPool, len);		byte[] buffer = null;		try {			// InputStream in = entity.getContent();			if (in == null) {				throw new IllegalArgumentException(						"input stream should not be null");			}			buffer = mPool.getBuf(len);			int count;			while ((count = in.read(buffer)) != -1) {				bytes.write(buffer, 0, count);			}			return bytes.toByteArray();		} finally {			mPool.returnBuf(buffer);			bytes.close();		}	}	public static String getFileAppendix(File f) {		return getFileAppendix(f.getName());	}	public static String getFileAppendix(String name) {		int pos = name.lastIndexOf('.');		if (pos > 0) {			return name.substring(pos);		}		return null;	}	public static FileInfo getFileInfo(String af) {		if (af == null || af.trim().equals("")) {			return null;		}		File file = new File(af);		if (file.exists()) {			return new FileInfo(file.lastModified(), 0, file.length());		} else {			return null;		}		// return null;	}	public static boolean copyFile(File srcFile, File destFile) {		boolean result = false;		try {			InputStream in = new FileInputStream(srcFile);			try {				result = copyToFile(in, destFile);			} finally {				in.close();			}		} catch (IOException e) {			//L.e(e);			result = false;		}		return result;	}	public static boolean copyToFile(InputStream inputStream, File destFile) {		try {			if (destFile.exists()) {				destFile.delete();			}			FileOutputStream out = new FileOutputStream(destFile);			byte[] buffer = null;			if (inputStream != null) {				try {					buffer = ByteArrayPool.getInstance().getBuf(2048);					int bytesRead;					while ((bytesRead = inputStream.read(buffer)) >= 0) {						out.write(buffer, 0, bytesRead);					}				} finally {					out.flush();					try {						out.getFD().sync();					} catch (IOException e) {					}					out.close();					ByteArrayPool.getInstance().returnBuf(buffer);				}			}			return true;		} catch (IOException e) {			return false;		}	}	public static final class FileStatus {		public int dev;		public int ino;		public int mode;		public int nlink;		public int uid;		public int gid;		public int rdev;		public long size;		public int blksize;		public long blocks;		public long atime;		public long mtime;		public long ctime;	}	/**	 * Get the status for the given path. This is equivalent to the POSIX	 * stat(2) system call.	 * 	 * @param path	 *            The path of the file to be stat'd.	 * @param status	 *            Optional argument to fill in. It will only fill in the status	 *            if the file exists.	 * @return true if the file exists and false if it does not exist. If you do	 *         not have permission to stat the file, then this method will	 *         return false.	 */	public static boolean getFileStatus(String path, FileStatus status) {		// StrictMode.noteDiskRead();		return false;	}	// private static native boolean getFileStatusNative(String path,	// FileStatus status);	/** Regular expression for safe filenames: no spaces or metacharacters */	private static final Pattern SAFE_FILENAME_PATTERN = Pattern			.compile("[\\w%+,./=_-]+");	// public static native int setPermissions(String file, int mode, int uid,	// int gid);	// public static native int getPermissions(String file, int[]	// outPermissions);	// public static native int setUMask(int mask);	/**	 * returns the FAT file system volume ID for the volume mounted at the given	 * mount point, or -1 for failure	 * 	 * @param mountPoint	 *            point for FAT volume	 * @return volume ID or -1	 */	// public static native int getFatVolumeId(String mountPoint);	// public String getFilePosition() {	// }	public static final String BASE_NAME = "Yingyonghui";	/**	 * Perform an fsync on the given FileOutputStream. The stream at this point	 * must be flushed but not yet closed.	 */	public boolean sync(FileOutputStream stream) {		try {			if (stream != null) {				stream.getFD().sync();			}			return true;		} catch (IOException e) {		}		return false;	}	// public boolean copyFile(File srcFile, File destFile) {	// boolean result = false;	// try {	// InputStream in = new FileInputStream(srcFile);	// try {	// result = copyToFile(in, destFile);	// } finally {	// in.close();	// }	// } catch (IOException e) {	// L.e(e);	// result = false;	// }	// return result;	// }	// public boolean copyToFile(InputStream inputStream, File destFile) {	// try {	// if (destFile.exists()) {	// destFile.delete();	// }	// FileOutputStream out = new FileOutputStream(destFile);	// byte[] buffer = null;	// try {	// buffer = ByteArrayPool.getInstance().getBuf(2048);	// int bytesRead;	// while ((bytesRead = inputStream.read(buffer)) >= 0) {	// out.write(buffer, 0, bytesRead);	// }	// } finally {	// out.flush();	// try {	// out.getFD().sync();	// } catch (IOException e) {	// }	// out.close();	// ByteArrayPool.getInstance().returnBuf(buffer);	// }	// return true;	// } catch (IOException e) {	// return false;	// }	// }	/**	 * Check if a filename is "safe" (no metacharacters or spaces).	 * 	 * @param file	 *            The file to check	 */	public boolean isFilenameSafe(String file) {		// Note, we check whether it matches what's known to be safe,		// rather than what's known to be unsafe. Non-ASCII, control		// characters, etc. are all unsafe by default.		return SAFE_FILENAME_PATTERN.matcher(file).matches();	}	public static String fileToString(File file) {		if (file != null && file.exists() && file.canRead()) {			BufferedReader rd = null;			try {				rd = new BufferedReader(new FileReader(file));				StringBuilder buf = new StringBuilder();				String tmp = null;				while ((tmp = rd.readLine()) != null) {					buf.append(tmp);				}				return buf.toString();			} catch (FileNotFoundException e) {				//L.e(e);			} catch (IOException e) {				//L.e(e);			} finally {				if (rd != null) {					try {						rd.close();					} catch (IOException e) {						// TODO Auto-generated catch block						e.printStackTrace();					}				}			}		}		return null;	}	/**	 * Read a text file into a String, optionally limiting the length.	 * 	 * @param file	 *            to read (will not seek, so things like /proc files are OK)	 * @param max	 *            length (positive for head, negative of tail, 0 for no limit)	 * @param ellipsis	 *            to add of the file was truncated (can be null)	 * @return the contents of the file, possibly truncated	 * @throws IOException	 *             if something goes wrong reading the file	 */	public String readTextFile(File file, int max, String ellipsis)			throws IOException {		InputStream input = new FileInputStream(file);		byte[] data = null;		try {			long size = file.length();			if (max > 0 || (size > 0 && max == 0)) { // "head" mode: read the														// first N bytes				if (size > 0 && (max == 0 || size < max))					max = (int) size;				data = ByteArrayPool.getInstance().getBuf(max + 1);				int length = input.read(data);				if (length <= 0)					return "";				if (length <= max)					return new String(data, 0, length);				if (ellipsis == null)					return new String(data, 0, max);				return new String(data, 0, max) + ellipsis;			} else if (max < 0) { // "tail" mode: keep the last N				int len;				boolean rolled = false;				byte[] last = null;				data = null;				do {					if (last != null)						rolled = true;					byte[] tmp = last;					last = data;					data = tmp;					if (data == null)						data = ByteArrayPool.getInstance().getBuf(-max);					len = input.read(data);				} while (len == data.length);				if (last == null && len <= 0)					return "";				if (last == null)					return new String(data, 0, len);				if (len > 0) {					rolled = true;					System.arraycopy(last, len, last, 0, last.length - len);					System.arraycopy(data, 0, last, last.length - len, len);				}				if (ellipsis == null || !rolled)					return new String(last);				return ellipsis + new String(last);			} else { // "cat" mode: size unknown, read it all in streaming						// fashion				ByteArrayOutputStream contents = new ByteArrayOutputStream();				int len;				data = ByteArrayPool.getInstance().getBuf(1024);				do {					len = input.read(data);					if (len > 0)						contents.write(data, 0, len);				} while (len == data.length);				return contents.toString();			}		} finally {			input.close();			ByteArrayPool.getInstance().returnBuf(data);		}	}	/**	 * Writes string to file. Basically same as "echo -n $string > $filename"	 * 	 * @param filename	 * @param string	 * @throws IOException	 */	public static void stringToFile(String filename, String string)			throws FileNotFoundException, IOException {		FileWriter out = new FileWriter(filename, true);		try {			out.write(string);		} finally {			out.close();		}	}	/**	 * Computes the checksum of a file using the CRC32 checksum routine. The	 * value of the checksum is returned.	 * 	 * @param file	 *            the file to checksum, must not be null	 * @return the checksum value or an exception is thrown.	 */	public static long checksumCrc32(File file) throws FileNotFoundException,			IOException {		CRC32 checkSummer = new CRC32();		CheckedInputStream cis = null;		byte[] buf = null;		try {			cis = new CheckedInputStream(new FileInputStream(file), checkSummer);			buf = ByteArrayPool.getInstance().getBuf(128);			while (cis.read(buf) >= 0) {				// Just read for checksum to get calculated.			}			return checkSummer.getValue();		} finally {			if (cis != null) {				try {					cis.close();				} catch (IOException e) {				}			}			ByteArrayPool.getInstance().returnBuf(buf);		}	}	public static File buildDicIfNoExist(String name) throws IOException {		File af = new File(name);		boolean build = false;		if (af.exists()) {			if (!af.isDirectory()) {				throw new IOException("can't build fold!");			} else {				build = true;			}		} else {			build = af.mkdirs();		}		if (!build) {			throw new IOException("can't build fold!");		}		return af;	}	public static File forceBuildDicIfNoExist(String name) throws IOException {		File af = new File(name);		boolean build = false;		if (af.exists()) {			if (!af.isDirectory()) {				boolean f = af.delete();				if (f) {					build = af.mkdirs();				} else {					throw new IOException("can't build fold!");				}			} else {				build = true;			}		} else {			build = af.mkdirs();		}		if (!build) {			throw new IOException("can't build fold!");		}		return af;	}	// public static static String readAllFile(File af) {	// BufferedReader rd = null;	// try {	// StringBuilder ret = new StringBuilder();	// rd = new BufferedReader(new FileReader(af));	// char[] buffer = new char[FILE_READ_BUFFER];	// int read;	// while ((read = rd.read(buffer)) > 0) {	// ret.append(buffer, 0, read);	// }	// return new String(ret);	// } catch (IOException ex) {	// L.e(ex);	// return null;	// } finally {	// try {	// rd.close();	// System.gc();	// } catch (IOException ex) {	// L.e(ex);	// }	// }	// }	public String checkFileMd5(String name) throws IOException {		return null;	}	// public RandomAccessFile prepareFile(String path, String name, long	// length)	// throws IOException {	// if (!isFilenameSafe(name)) {	// name = name.toLowerCase().replaceAll("[^a-z0-9_]", "_");	// }	// File af = new File(path, name);	// if (af.exists()) {	// af.delete();	// }	// RandomAccessFile ret = new RandomAccessFile(af, "rw");	// ret.setLength(length);	// return ret;	// }	// public byte[] checkFilePart(RandomAccessFile raf, long start, int length)	// throws IOException {	// if (raf == null) {	// return null;	// }	// raf.seek(start);	// FileChannel afc = raf.getChannel();	// ByteBuffer bb = ByteBuffer.allocate(length);	// afc.read(bb);	// return bb.array();	// }	//	// public boolean checkFilePartMd5(RandomAccessFile raf, long start,	// int length, byte[] src) throws IOException {	// byte[] dst = checkFilePart(raf, start, length);	// String dstRes = StringHelper.HashHandler.getHashValue(dst,	// HashMethod.md5);	// String srcRes = StringHelper.HashHandler.getHashValue(src,	// HashMethod.md5);	// return dstRes.equals(srcRes);	// }	//	// public boolean writeFromStream(BufferedInputStream ins, int size,	// FileChannel dist) throws IOException {	// byte[] buffer = new byte[size];	// int read = ins.read(buffer);	// ByteBuffer bb = ByteBuffer.wrap(buffer, 0, read);	// bb.flip();	// dist.write(bb);	// dist.force(true);	// return read == size;	// }	public static boolean createNewFile(File dist) throws IOException {		if (dist.exists()) {			if (!dist.delete()) {				return false;			}		}		File p = dist.getParentFile();		if (p != null && !p.exists()) {			p = forceBuildDicIfNoExist(p.getAbsolutePath());			if (p == null) {				return false;			}		}		if (!dist.createNewFile()) {			return false;		}		return true;	}	public static boolean createFileFoler(File dist) {		if (!dist.exists()) {			return dist.mkdirs();		} else if (dist.isFile()) {			if (dist.delete()) {				return dist.mkdirs();			}			return false;		}		return true;	}	public static void clearFolder(File folder) {		if (folder.isDirectory()) {			File[] fs = folder.listFiles();			if (fs != null && fs.length > 0) {				for (File f : fs) {					if (f.isFile())						f.delete();					else if (f.isDirectory()) {						clearFolder(f);					}				}			}		}	}	public static boolean delFolder(File folder) {		clearFolder(folder);		return folder.delete();	}	public static long getFolderSize(File folder) {		int ret = 0;		if (folder.exists() && folder.isDirectory()) {			File[] fs = folder.listFiles();			if(fs != null){				for (File f : fs) {					if (f.isFile())						ret += f.length();					else						ret += getFolderSize(f);				}			}		}		return ret;	}	public static boolean writeResToFile(byte[] src, File dist) {		try {			if (!dist.exists()) {				dist.createNewFile();			}			if (dist != null && dist.exists() && dist.isFile()					&& dist.canWrite()) {				FileOutputStream af = new FileOutputStream(dist);				af.write(src);				af.flush();				af.close();				return true;			}		} catch (Exception e) {			//L.e(e);		}		return false;	}	public static byte[] readBinaryFile(File f) {		return null;	}	public static File buildFolder(int type) throws IOException {		File base = null;		File folder = null;		try {			folder = new File(Environment.getExternalStorageDirectory(),					BASE_NAME);			if (!folder.exists()) {				folder.mkdirs();			}			String folderName = null;			if (type == FileHelper.FOLDER_TYPE_LOG) {				folderName = FileHelper.LOG_FOLDER_NAME;			} else if (type == FileHelper.FOLDER_TYPE_DB) {				folderName = FileHelper.DB_FOLDER_NAME;			}			base = new File(folder, folderName);			if (!base.exists()) {				base.mkdirs();			}		} catch (Exception ex) {			//L.e(ex);		}		if (base != null)			return base;		else			throw new IOException("can't build folder");	}	public static File getBaseFile() throws IOException {		// File base = null;		File folder = null;		try {			folder = new File(Environment.getExternalStorageDirectory(),					BASE_NAME);			if (!folder.exists()) {				folder.mkdirs();			}		} catch (Exception ex) {			//L.e(ex);		}		if (folder != null)			return folder;		else			throw new IOException("can't build folder");	}}