package kimxu.hhs.z_volley.tools;import android.annotation.SuppressLint;import org.json.JSONException;import org.json.JSONObject;import java.io.BufferedInputStream;import java.io.BufferedOutputStream;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.OutputStream;import java.io.UnsupportedEncodingException;import java.lang.reflect.Type;import java.math.BigInteger;import java.net.URLDecoder;import java.net.URLEncoder;import java.security.InvalidKeyException;import java.security.Key;import java.security.KeyPair;import java.security.KeyPairGenerator;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;import java.security.PrivateKey;import java.security.PublicKey;import java.security.SecureRandom;import java.security.interfaces.RSAPrivateKey;import java.security.interfaces.RSAPublicKey;import java.security.spec.InvalidKeySpecException;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.ArrayList;import java.util.Calendar;import java.util.Collection;import java.util.Date;import java.util.Iterator;import java.util.List;import java.util.Locale;import java.util.Map;import java.util.Random;import java.util.Scanner;import java.util.logging.Level;import java.util.logging.Logger;import java.util.regex.Matcher;import java.util.regex.Pattern;import javax.crypto.BadPaddingException;import javax.crypto.Cipher;import javax.crypto.CipherInputStream;import javax.crypto.CipherOutputStream;import javax.crypto.IllegalBlockSizeException;import javax.crypto.NoSuchPaddingException;import javax.crypto.spec.IvParameterSpec;import javax.crypto.spec.SecretKeySpec;import kimxu.hhs.z_gson.Gson;import kimxu.hhs.z_gson.JsonElement;import kimxu.hhs.z_gson.JsonSyntaxException;import kimxu.hhs.z_volley.structure.CollectionBuilder;public final class StringHelper {	public static final Pattern pattern = Pattern.compile("\\{(\\w+)\\}\\s*");	public static class JsonHelper {		public static final Gson gson = new Gson();		public static String toJson(Object src) {			return gson.toJson(src);		}		public static <T> T fromJson(String src, Class<T> c) {			try {				return gson.fromJson(src, c);			} catch (JsonSyntaxException ex) {				//L.e(ex);				return null;			}		}		public static <T> T fromJson(JsonElement src, Class<T> c) {			try {				return gson.fromJson(src, c);			} catch (JsonSyntaxException ex) {				//L.e(ex);				return null;			}		}		public static List fromJson(String src, Type c) {			try {				return gson.fromJson(src, c);			} catch (JsonSyntaxException ex) {				//L.e(ex);				return null;			}		}		public static Map<String, Object> buildMap(String src) {			Map<String, Object> ret = CollectionBuilder.newHashMap();			try {				JSONObject obj = new JSONObject(src);				@SuppressWarnings("unchecked")				Iterator<String> iter = obj.keys();				while (iter.hasNext()) {					String key = iter.next();					Object vl = obj.opt(key);					if (vl instanceof String || vl instanceof Integer							|| vl instanceof Long || vl instanceof Double) {						ret.put(key, vl);					}				}			} catch (JSONException e) {				//L.e(e);			}			return ret;		}	}	public static class SizeHandler {		static final String[] unit = { "B", "KB", "MB", "GB", "TB", "PB" };		static final int D = 1024;		static final String NO_RESULT = "无法计算";		public static final String getSizeStr(final long size) {			// String ret = null;			int unitIndex = 0;			double mn = size;			while (mn > D) {				mn = mn / D;				// rn = mn % D;				++unitIndex;			}			mn = Math.floor(mn * 10) / 10;			if (unitIndex > unit.length) {				return NO_RESULT;			}			return mn + unit[unitIndex];		}	}	public static class EncryptHandler {		private static final String ALGO = "AES";		private static final String ALGO_FILE = "AES/CFB8/NoPadding";		private static final Cipher cipher;		static final int a = (int) 'a';		static final int z = (int) 'z';		static final int aa = (int) 'A';		static final int zz = (int) 'Z';		static final int n0 = (int) '0';		static final int n9 = (int) '9';		static final int st = (int) '*';		static final int se = (int) '@';		private static final int IV_LENGTH = 16;		private static final int SIZE = 50 * 1024;		private static final int FILE_SIZE = 32 * 1024;		// private final Cipher cipher;		private static final Cipher fileCipher;		static {			Cipher cc = null;			Cipher fc = null;			try {				cc = Cipher.getInstance(ALGO);				fc = Cipher.getInstance(ALGO_FILE);			} catch (NoSuchAlgorithmException ex) {				Logger.getLogger(EncryptHandler.class.getName()).log(						Level.SEVERE, null, ex);			} catch (NoSuchPaddingException ex) {				Logger.getLogger(EncryptHandler.class.getName()).log(						Level.SEVERE, null, ex);			} finally {				cipher = cc;				fileCipher = fc;			}		}		private EncryptHandler(String k, boolean flag) throws Exception {		}		public static byte[] encrypt(byte[] data, String k)				throws InvalidKeyException, IllegalBlockSizeException,				BadPaddingException, NoSuchAlgorithmException,				InvalidKeySpecException {			Key key = generateKey(k);			cipher.init(Cipher.ENCRYPT_MODE, key);			byte[] ret = cipher.doFinal(data);			// byte[] ret = new Base64().encode(encVal);			return ret;		}		public byte[] decrypt(byte[] data, String k)				throws IllegalBlockSizeException, BadPaddingException,				InvalidKeyException, NoSuchAlgorithmException,				InvalidKeySpecException {			// byte[] dec = new Base64().decode(data);			Key key = generateKey(k);			cipher.init(Cipher.DECRYPT_MODE, key);			byte[] ret = cipher.doFinal(data);			return ret;		}		// public byte[] encrypt(byte[] data, int offset, int len) throws		// InvalidKeyException, IllegalBlockSizeException, BadPaddingException {		// byte[] ret = cipher.doFinal(data, offset, len);		// //byte[] ret = new Base64().encode(encVal);		// return ret;		// }		//		// public byte[] decrypt(byte[] data, int offset, int len) throws		// IllegalBlockSizeException, BadPaddingException, InvalidKeyException {		// // byte[] dt = Arrays.copyOfRange(data, offset, len);		// // byte[] dec = new Base64().decode(dt);		// byte[] decVal = cipher.doFinal(data, offset, len);		// return decVal;		// }		@SuppressLint("NewApi")		public static String encrypt(String data, String keyValue) {			try {				Key key = generateKey(keyValue);				cipher.init(Cipher.ENCRYPT_MODE, key);				byte[] encVal = cipher.doFinal(data.getBytes());				String encryptedValue = new String(Base64.encodeToByte(encVal,						false));				return encryptedValue;			} catch (NoSuchAlgorithmException ex) {				Logger.getLogger(EncryptHandler.class.getName()).log(						Level.SEVERE, null, ex);			} catch (InvalidKeySpecException ex) {				Logger.getLogger(EncryptHandler.class.getName()).log(						Level.SEVERE, null, ex);			} catch (IllegalBlockSizeException ex) {				Logger.getLogger(EncryptHandler.class.getName()).log(						Level.SEVERE, null, ex);			} catch (BadPaddingException ex) {				Logger.getLogger(EncryptHandler.class.getName()).log(						Level.SEVERE, null, ex);			} catch (InvalidKeyException ex) {				Logger.getLogger(EncryptHandler.class.getName()).log(						Level.SEVERE, null, ex);			}			return "";		}		@SuppressLint("NewApi")		public static String decrypt(String encryptedData, String keyValue) {			try {				Key key = generateKey(keyValue);				// Cipher c = Cipher.getInstance(ALGO);				cipher.init(Cipher.DECRYPT_MODE, key);				byte[] decordedValue = Base64.decode(encryptedData);				byte[] decValue = cipher.doFinal(decordedValue);				String decryptedValue = new String(decValue);				return decryptedValue;			} catch (NoSuchAlgorithmException ex) {				Logger.getLogger(EncryptHandler.class.getName()).log(						Level.SEVERE, null, ex);			} catch (InvalidKeySpecException ex) {				Logger.getLogger(EncryptHandler.class.getName()).log(						Level.SEVERE, null, ex);			} catch (IllegalBlockSizeException ex) {				Logger.getLogger(EncryptHandler.class.getName()).log(						Level.SEVERE, null, ex);			} catch (BadPaddingException ex) {				Logger.getLogger(EncryptHandler.class.getName()).log(						Level.SEVERE, null, ex);			} catch (InvalidKeyException ex) {				Logger.getLogger(EncryptHandler.class.getName()).log(						Level.SEVERE, null, ex);			}			return "";		}		// private static Key generateFileKey(String password) throws		// NoSuchAlgorithmException, InvalidKeySpecException {		// byte[] salt = new byte[8];		// Random rnd = new Random();		// rnd.nextBytes(salt);		// SecretKeyFactory factory =		// SecretKeyFactory.getInstance("PBKDF2WithHmacSHA1");		// KeySpec spec = new PBEKeySpec(password.toCharArray(), salt, 65536,		// 256);		// SecretKey tmp = factory.generateSecret(spec);		// SecretKey secret = new SecretKeySpec(tmp.getEncoded(), "AES");		// return secret;		// }		private static Key generateKey(String password)				throws NoSuchAlgorithmException, InvalidKeySpecException {			// KeyGenerator kgen = KeyGenerator.getInstance(ALGO);			// SecureRandom secureRandom = SecureRandom.getInstance("SHA1PRNG");			//			// secureRandom.setSeed(password.getBytes());			//			// kgen.init(56, secureRandom);			//			// //kgen.init(128, new SecureRandom(password.getBytes()));			//			// SecretKey secretKey = kgen.generateKey();			//			// byte[] enCodeFormat = secretKey.getEncoded();			//			// SecretKeySpec key = new SecretKeySpec(enCodeFormat, ALGO);			Key key = new SecretKeySpec(password.getBytes(), ALGO);			return key;		}		public static String randomKey(int n) {			StringBuilder ret = new StringBuilder();			Random ran = new Random();			ran.setSeed(System.currentTimeMillis());			int nn = n < 16 ? 16 : n;			for (int i = 0; i < nn; ++i) {				int method = (int) (Math.random() * 4);				if (method == 0) {					char ch = (char) Math.floor(ran.nextDouble() * (z - a) + a);					ret.append(ch);				} else if (method == 1) {					char ch = (char) Math.floor(ran.nextDouble() * (zz - aa)							+ aa);					ret.append(ch);				} else if (method == 2) {					char ch = (char) Math.floor(ran.nextDouble() * (n9 - n0)							+ n0);					ret.append(ch);				} else if (method == 3) {					char ch = (char) Math.floor(ran.nextDouble() * (se - st)							+ st);					ret.append(ch);				}			}			return new String(ret);		}		public static String randomPass(int n) {			StringBuilder ret = new StringBuilder();			Random ran = new Random();			ran.setSeed(System.currentTimeMillis());			for (int i = 0; i < n; ++i) {				int method = (int) (Math.random() * 3);				if (method == 0) {					char ch = (char) Math.floor(ran.nextDouble() * (z - a) + a);					ret.append(ch);				} else if (method == 1) {					char ch = (char) Math.floor(ran.nextDouble() * (zz - aa)							+ aa);					ret.append(ch);				} else if (method == 2) {					char ch = (char) Math.floor(ran.nextDouble() * (n9 - n0)							+ n0);					ret.append(ch);				}			}			return new String(ret);		}		// ***********************************************************************************************//		public static byte[] encryptFile(String plainText, String password)				throws Exception {			ByteArrayInputStream bis = new ByteArrayInputStream(					plainText.getBytes("UTF8"));			ByteArrayOutputStream bos = new ByteArrayOutputStream();			encrypt(bis, bos, password);			return bos.toByteArray();		}		public static byte[] decryptFile(String cipherText, String password)				throws Exception {			byte[] cipherTextBytes = cipherText.getBytes();			ByteArrayInputStream bis = new ByteArrayInputStream(cipherTextBytes);			ByteArrayOutputStream bos = new ByteArrayOutputStream();			decrypt(bis, bos, password);			return bos.toByteArray();		}		public static void encrypt(InputStream in, OutputStream out,				String password) throws Exception {			SecureRandom r = new SecureRandom();			byte[] iv = new byte[IV_LENGTH];			r.nextBytes(iv);			out.write(iv); // write IV as a prefix			out.flush();			// System.out.println(">>>>>>>>written"+Arrays.toString(iv));			// Cipher cipher = Cipher.getInstance("AES/CFB8/NoPadding");			// //"DES/ECB/PKCS5Padding";"AES/CBC/PKCS5Padding"			SecretKeySpec keySpec = new SecretKeySpec(password.getBytes(),					"AES");			IvParameterSpec ivSpec = new IvParameterSpec(iv);			fileCipher.init(Cipher.ENCRYPT_MODE, keySpec, ivSpec);			out = new CipherOutputStream(out, fileCipher);			byte[] buf = new byte[SIZE];			int numRead = 0;			while ((numRead = in.read(buf)) >= 0) {				out.write(buf, 0, numRead);			}			in.close();			out.close();		}		public static void decrypt(InputStream in, OutputStream out,				String password) throws Exception {			byte[] iv = new byte[IV_LENGTH];			in.read(iv);			// System.out.println(">>>>>>>>red"+Arrays.toString(iv));			// Cipher cipher = Cipher.getInstance("AES/CFB8/NoPadding");			// //"DES/ECB/PKCS5Padding";"AES/CBC/PKCS5Padding"			SecretKeySpec keySpec = new SecretKeySpec(password.getBytes(),					"AES");			IvParameterSpec ivSpec = new IvParameterSpec(iv);			fileCipher.init(Cipher.DECRYPT_MODE, keySpec, ivSpec);			in = new CipherInputStream(in, fileCipher);			byte[] buf = new byte[SIZE];			int numRead = 0;			while ((numRead = in.read(buf)) >= 0) {				out.write(buf, 0, numRead);			}			in.close();			out.close();		}		public static byte[] handleDecrypt(String inFile, String password)				throws Exception {			BufferedInputStream is = new BufferedInputStream(					new FileInputStream(inFile));			ByteArrayOutputStream os = new ByteArrayOutputStream(FILE_SIZE);			decrypt(is, os, password);			is.close();			return os.toByteArray();		}		public static void handleEncrypt(byte[] data, String outFile,				String password) throws Exception {			ByteArrayInputStream is = new ByteArrayInputStream(data);			BufferedOutputStream os = new BufferedOutputStream(					new FileOutputStream(outFile));			encrypt(is, os, password);			os.flush();			os.close();		}		public static File handle(int mode, String inputFile,				String outputFile, String password) throws Exception {			File ret = new File(outputFile);			BufferedInputStream is = new BufferedInputStream(					new FileInputStream(inputFile));			BufferedOutputStream os = new BufferedOutputStream(					new FileOutputStream(ret));			if (mode == Cipher.ENCRYPT_MODE) {				encrypt(is, os, password);			} else if (mode == Cipher.DECRYPT_MODE) {				decrypt(is, os, password);			} else {				throw new Exception("unknown mode");			}			is.close();			os.close();			return ret;		}	}	public static class RSAHandler {		static final int radix = 16;		static final int KEY_SIZE = 1024;		public static final int MAX_SIZE = 128;		public static void saveKey(KeyPair pair, String base)				throws FileNotFoundException, IOException {			PrivateKey privateKey = pair.getPrivate();			PublicKey publicKey = pair.getPublic();			// Save Pirvate Key			FileOutputStream f1 = new FileOutputStream(base + "private.ppk");			ObjectOutputStream b1 = new ObjectOutputStream(f1);			b1.writeObject(privateKey);			// Save Public Key			FileOutputStream f2 = new FileOutputStream(base + "public.ppk");			ObjectOutputStream b2 = new ObjectOutputStream(f2);			b2.writeObject(publicKey);		}		public static BigInteger[] getParam(String file, int type)				throws FileNotFoundException, IOException,				ClassNotFoundException {			BigInteger n, e;			FileInputStream f = new FileInputStream(file);			ObjectInputStream b = new ObjectInputStream(f);			if (type == 0) {				RSAPublicKey pbk = (RSAPublicKey) b.readObject();				e = pbk.getPublicExponent();				n = pbk.getModulus();			} else {				RSAPrivateKey prk = (RSAPrivateKey) b.readObject();				e = prk.getPrivateExponent();				n = prk.getModulus();			}			b.close();			return new BigInteger[] { e, n };		}		public static String encrypt(String msg, BigInteger[] e)				throws UnsupportedEncodingException {			byte ptext[] = msg.getBytes("UTF-8");			BigInteger m = new BigInteger(ptext);			BigInteger c = m.modPow(e[0], e[1]);			String cs = c.toString(radix);			return cs;		}		/*		 * Key: m =		 * 13382700397842331480471697762887048077099067117069331445189511358810041876510447630394306695085604701032772158108023321937321071224962312860472321488393699073560145458985648439392974470988622824846017170155100783204105744470948919469506905134346753420325758285521759950170160314720922867916049648921031942913		 * e = 65537 d =		 * 13278762248361858667807704992981353469911624524906304609881189933025610008784677182496619860048929650407542424850825344140563568970457135369192885267059293141637871179523098592874898947776220735531286795691997223167224246881856056954599175982380721938036043547500477094560383188473499174712586543478311098193		 */		public static String decrypt(String ctext, BigInteger d[])				throws UnsupportedEncodingException {			BigInteger c = new BigInteger(ctext, radix);			BigInteger m = c.modPow(d[0], d[1]);			byte[] mt = m.toByteArray();			return new String(mt, "UTF-8");		}		public static KeyPair generateKeyPair() throws NoSuchAlgorithmException {			KeyPairGenerator keyPairGen = KeyPairGenerator.getInstance("RSA");			keyPairGen.initialize(KEY_SIZE, new SecureRandom());			KeyPair keyPair = keyPairGen.genKeyPair();			// RSAPrivateKey prk = (RSAPrivateKey) keyPair.getPrivate();			// RSAPublicKey pbk = (RSAPublicKey) keyPair.getPublic();			// BigInteger e = pbk.getPublicExponent();			// BigInteger n = pbk.getModulus();			// BigInteger d = prk.getPrivateExponent();			// System.out.println("e: "+e);			// System.out.println("n: "+n);			// System.out.println("d: "+d);			return keyPair;		}		public static String encryptLongStr(String signStr, int n,				BigInteger[] param) throws UnsupportedEncodingException {			String remain = signStr;			StringBuilder sign = new StringBuilder();			do {				String cur = remain.substring(0, n);				// System.out.println(cur);				sign.append(encrypt(cur, param)).append(";");				remain = remain.substring(n);			} while ((remain.length() > n));			sign.append(encrypt(remain, param)).append(";");			return sign.toString();		}		public static String decryptLongStr(String str, BigInteger[] param)				throws UnsupportedEncodingException {			StringBuilder ret = new StringBuilder();			Scanner sc = new Scanner(str);			sc.useDelimiter(";");			while (sc.hasNext()) {				ret.append(decrypt(sc.next(), param));			}			return ret.toString();		}	}	public static class HashHandler {		public static enum HashMethod {			sha1("SHA1"), sha512("SHA-512"), md5("MD5");			final MessageDigest method;			private HashMethod(String mn) {				MessageDigest m = null;				try {					m = MessageDigest.getInstance(mn);				} catch (NoSuchAlgorithmException ex) {					Logger.getLogger(HashHandler.class.getName()).log(							Level.SEVERE, null, ex);				} finally {					method = m;				}			}		}		static final char[] byteToStr = new char[] { '0', '1', '2', '3', '4',				'5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };		// 7c4a8d09ca3762af61e59520943dc26494f8941b		// e10adc3949ba59abbe56e057f20f883e		// 7c4a8d09ca3762af61e59520943dc26494f8941b		// e10adc3949ba59abbe56e057f20f883e		public static String getHashValue(String str) {			return getHashValue(str, HashMethod.md5);		}		public static String getHashValue(byte[] str, HashMethod sh1) {			MessageDigest md = sh1.method;			md.reset();			md.update(str);			final byte[] resultByte = md.digest();			return encodeHex(resultByte);		}		public static String getHashValue(String str, HashMethod sh1) {			MessageDigest md = sh1.method;			md.reset();			md.update(str.getBytes());			final byte[] resultByte = md.digest();			return encodeHex(resultByte);		}		public static String encodeHex(byte[] in) {			int n = in.length, k = n * 2;			int size = k >= 512 ? 512 : k;			char[] re = new char[size];			if (n > 0) {				StringBuilder sb = new StringBuilder();				int cur = 0;				for (int i = 0; i < n; ++i) {					int hc = (in[i] >> 4) & 0x0f;					int lc = in[i] & 0x0f;					re[cur] = byteToStr[hc];					re[cur + 1] = byteToStr[lc];					if (cur >= size) {						sb.append(re, 0, cur);						cur = 0;						// Arrays.fill(re, val);					} else {						cur += 2;					}				}				if (cur > 0) {					sb.append(re, 0, cur);				}				return sb.toString();			}			return "";		}		// public static String asHex(byte[] b) {		// StringBuffer buf = new StringBuffer();		// for (int i = 0; i < b.length; i++) {		// buf.append(Integer.toString((b[i] & 0xff) + 0x100, 16)		// .substring(1));		// }		// String result = buf.toString();		// return result;		// }		public static String getFileHashCode(String loc)				throws FileNotFoundException, IOException {			return getFileHashCode(loc, HashMethod.md5);		}		public static String getFileHashCode(String loc, HashMethod sh1)				throws FileNotFoundException, IOException {			MessageDigest md = sh1.method;			FileInputStream fis = new FileInputStream(loc);			try {				byte[] dataBytes = new byte[1024];				int nread = 0;				while ((nread = fis.read(dataBytes)) != -1) {					md.update(dataBytes, 0, nread);				}				;				byte[] mdbytes = md.digest();				// convert the byte to hex format				// StringBuilder sb = new StringBuilder("");				// for (int i = 0; i < mdbytes.length; i++) {				// sb.append(Integer.toString((mdbytes[i] & 0xff) + 0x100,				// 16).substring(1));				// }				return encodeHex(mdbytes);			} finally {				if (fis != null) {					fis.close();				}			}		}	}	public static class URLGenerator {		public static String ipToStr(byte[] ip) {			if (ip.length == 4) {				StringBuilder ipStr = new StringBuilder();				for (int i = 0; i < 4; ++i) {					ipStr.append(".").append((int) (ip[i] & 0x0ff));				}				if (ipStr.length() > 1) {					ipStr.deleteCharAt(0);				}				return ipStr.toString();			} else if (ip.length == 6) {			}			return null;		}		public static String encodeUrl(String s) {			try {				return URLEncoder.encode(s, "UTF-8");			} catch (UnsupportedEncodingException e) {				//L.e(e);			}			return null;		}		public static String decodeUrl(String s) {			try {				return URLDecoder.decode(s, "UTF-8");			} catch (UnsupportedEncodingException e) {				//L.e(e);			}			return null;		}	}	public static class DataTimeHanlder {		public static final String SHORT_TIME_FORMAT = "HH:mm";		public static final String LONG_TIME_FORMAT = "HH:mm:ss";		public static final String SHORT_DATE_FORMAT = "MM/dd";		public static final String LONG_DATE_FORMAT = "yyyy-MM-dd";		public static final String SHORT_DATE_SHORT_TIME_FORMAT = "MM/dd HH:mm";		public static final String LONG_DATE_LONG_TIME_FORMAT = "yyyy-MM-dd HH:mm:ss";		public static final String LONG_DATE_SHORT_TIME_FORMAT = "yyyy-MM-dd HH:mm";		public static final String DATA_FORMAT = "yyyy-MM-dd HH:mm:ss SSS";		public static final long[] SPANS = { 1000, 60, 60, 24, 30, 12, 100 };		public static final String[] SPAN_TAGS = { "刚才", "秒", "分钟", "小时", "天",				"月", "年", "世纪" };		public static final int[] COMMON_FIELDS = { Calendar.YEAR,				Calendar.MONTH, Calendar.DAY_OF_MONTH, Calendar.HOUR_OF_DAY,				Calendar.MINUTE, Calendar.SECOND };		public static final Calendar calendar = Calendar.getInstance();		public static final SimpleDateFormat formatter = new SimpleDateFormat(				LONG_DATE_SHORT_TIME_FORMAT, Locale.SIMPLIFIED_CHINESE);		public static String getCurrentDateTimeString(String format) {			setFormat(format);			return formatter.format(new Date(System.currentTimeMillis()));		}		public static String getDateTimeString(String format, Date date) {			setFormat(format);			return formatter.format(date);		}		public static String getTimeSpanStringFromNow(Date date) {			return getTimeSpanString(date, null, false);		}		public static String getTimeSpanString(Date dateFrom, Date dateTo,				boolean accurate) {			if (dateFrom == null) {				dateFrom = new Date();			} else if (dateTo == null) {				dateTo = new Date();			}			long span = dateTo.getTime() - dateFrom.getTime();			String tag = span < 0 ? "后" : "前";			span = Math.abs(span);			int index = 0;			long timeLeap = 0, leap, remain;			StringBuilder ret = new StringBuilder();			String spanStr;			do {				leap = SPANS[index];				timeLeap = span / leap;				remain = span % leap;				spanStr = remain + SPAN_TAGS[index];				ret.insert(0, spanStr);				++index;				span = timeLeap;				// System.out.println(span + " ");			} while (timeLeap > 0);			return accurate ? ret.append(tag).toString() : spanStr + tag;		}		public static Date parseDate(String date, String format) {			setFormat(format);			try {				return formatter.parse(date);			} catch (ParseException ex) {				Logger.getLogger(StringHelper.class.getName()).log(						Level.SEVERE, null, ex);				return new Date(0);			}		}		public static List<Integer> parseDateToInt(String date, String format,				int[] fields) {			setFormat(format);			if (fields == null) {				fields = COMMON_FIELDS;			}			ArrayList<Integer> ret = new ArrayList<Integer>(10);			try {				Date d = formatter.parse(date);				calendar.setTime(d);				for (int fi : fields) {					ret.add(calendar.get(fi));				}			} catch (ParseException ex) {				Logger.getLogger(StringHelper.class.getName()).log(						Level.SEVERE, null, ex);			}			return ret;		}		public static String calculateDateStringFormNow(String format,				int span, int field) {			return calculateDateString(new Date(), format, span, field);		}		public static String calculateDateString(Date from, String format,				int span, int field) {			setFormat(format);			calendar.setTime(from);			calendar.add(field, span);			return formatter.format(calendar.getTime());		}		public static Date getDateFromInts(int[] params, int[] fields) {			if (fields == null) {				fields = COMMON_FIELDS;			}			calendar.clear();			if (params.length == fields.length) {				for (int i = 0, n = fields.length; i < n; ++i) {					calendar.set(fields[i], params[i]);				}			}			return calendar.getTime();		}		private static void setFormat(String format) {			if (format != null) {				formatter.applyPattern(format);			} else {				formatter.applyPattern(LONG_DATE_SHORT_TIME_FORMAT);			}		}	}	public static String concat(Object... args) {		if (args.length > 0) {			StringBuilder ret = new StringBuilder();			for (Object s : args) {				// if(s==null){				// s="null";				// }				ret.append(s);			}			return ret.toString();		} else {			return "";		}	}	public static String concat(String spliter, Object[] args) {		if (args.length > 1) {			StringBuilder ret = new StringBuilder();			int n = spliter.length();			for (Object s : args) {				if (s == null) {					s = "null";					ret.append(spliter).append(s == null ? " " : s.toString());				} else if (!s.getClass().isArray()) {					ret.append(spliter).append(s == null ? " " : s.toString());				} else {					Object[] ss = (Object[]) s;					ret.append("[");					for (Object obj : ss) {						ret.append(obj.toString()).append(",");					}					ret.append("]");				}			}			if (ret.length() > n) {				ret.delete(0, n);			}			return ret.toString();		} else if (args.length == 1) {			return args[0].toString();		} else {			return "";		}	}	@SuppressWarnings("unchecked")	public static String concat(String format, String spliter, List<Object> args) {		int n = args.size();		if (n > 1) {			int len = spliter.length();			StringBuilder ret = new StringBuilder();			for (Object arg : args) {				Object[] p;				if (arg instanceof List) {					List<Object> l = (List<Object>) arg;					p = l.toArray();				} else {					p = new Object[] { arg };				}				String s = String.format(format, p);				ret.append(spliter).append(s);			}			if (ret.length() > len) {				ret.delete(0, len);			}			return ret.toString();		} else if (n == 1) {		}		return "";	}	public static class Cn2py {		private static int BEGIN = 45217;		private static int END = 63486;		private static char[] chartable = { '啊', '芭', '擦', '搭', '蛾', '发', '噶',				'哈', '哈', '击', '喀', '垃', '妈', '拿', '哦', '啪', '期', '然', '撒',				'塌', '塌', '塌', '挖', '昔', '压', '匝', };		private static int[] table = new int[27];		private static char[] initialtable = { 'a', 'b', 'c', 'd', 'e', 'f',				'g', 'h', 'h', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r',				's', 't', 't', 't', 'w', 'x', 'y', 'z', };		static {			for (int i = 0; i < 26; i++) {				table[i] = gbValue(chartable[i]);			}			table[26] = END;		}		public static String cn2py(String SourceStr) {			SourceStr = SourceStr.replaceAll("[^A-Za-z\\d\\u4E00-\\u9FA5]", "");			String Result = "";			int StrLength = SourceStr.length();			int i;			try {				for (i = 0; i < StrLength; i++) {					Result += Char2Initial(SourceStr.charAt(i));				}			} catch (Exception e) {				Result = "";			}			return Result;		}		public static String cn2pyf(String SourceStr) {			SourceStr = SourceStr.replaceAll("[^A-Za-z\\d\\u4E00-\\u9FA5]", "");			String Result = null;			try {				if (SourceStr.length() > 0) {					Result = Char2Initial(SourceStr.charAt(0)) + "";				}			} catch (Exception e) {				Result = null;				;			}			return Result;		}		private static char Char2Initial(char ch) {			if (ch >= 'a' && ch <= 'z')				return (char) (ch - 'a' + 'A');			if (ch >= 'A' && ch <= 'Z')				return ch;			int gb = gbValue(ch);			if ((gb < BEGIN) || (gb > END))				return ch;			int i;			for (i = 0; i < 26; i++) {				if ((gb >= table[i]) && (gb < table[i + 1]))					break;			}			if (gb == END) {				i = 25;			}			return initialtable[i];		}		private static int gbValue(char ch) {			String str = new String();			str += ch;			try {				byte[] bytes = str.getBytes("GB2312");				if (bytes.length < 2)					return 0;				return (bytes[0] << 8 & 0xff00) + (bytes[1] & 0xff);			} catch (Exception e) {				return 0;			}		}	}	@SuppressLint("DefaultLocale")	public static String lowerFirstCase(String str) {		if (str != null) {			if (str.length() > 1) {				String first = str.substring(0, 1).toLowerCase();				return first + str.substring(1);			} else {				return str.toLowerCase();			}		}		return null;	}	public static int getStringSum(String src) {		int re = 0, limit = 2048, i = 0;		byte[] bs = src.getBytes();		for (byte b : bs) {			if (i++ < limit) {				re += b;			} else {				break;			}		}		return re;	}	public static String concat(Collection<?> c) {		StringBuilder ret = new StringBuilder();		if (c != null && c.size() > 0) {			for (Object x : c) {				ret.append(",").append(x.toString());			}			if (ret.length() > 0) {				ret.deleteCharAt(0);			}		}		return ret.toString();	}	public static String genStr(String prefix, String target,			Map<String, Object> param) {		StringBuilder ret = new StringBuilder(prefix);		Matcher m = pattern.matcher(target);		int start = 0;		if (param != null) {			while (m.find(start)) {				String k = m.group(1);				if (param.containsKey(k)) {					String kk = param.get(k).toString();					// if (!kk.equals("___")) {					ret.append(target.subSequence(start, m.start()));					ret.append(kk);					start = m.end();					// }				} else {					throw new IllegalArgumentException(StringHelper.concat(							"param ", k, " not set "));				}			}		}		if (start < target.length()) {			ret.append(target.substring(start));		}		return ret.toString();	}	public static String chopToSize(String str, int len) {		int n = str.length();		if (n > len && len > 1) {			String s = str.substring(0, len - 1);			return s + "...";		}		return str;	}}